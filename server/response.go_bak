package request

/*
    响应案例，迅掣根据这种方式，按照实际接口的数据格式重新定义
*/

import (
	"encoding/json"
	"gitee.com/idigpower/tros/common/constant"
	trlogger "gitee.com/idigpower/tros/logx"
	"net/http"
	"time"

	context2 "gitee.com/idigpower/tros/app/context"
	"github.com/astaxie/beego/validation"
	"github.com/gin-gonic/gin"
)

type Gin struct {
	C *gin.Context
}

type Response struct {
	Code      int32       `json:"code"`
	Msg       string      `json:"msg"`
	RequestId string      `json:"request_id"`
	Time      time.Time   `json:"time"`
	Data      interface{} `json:"data"`
}

func (g *Gin) Response(httpCode, errCode int32, data interface{}) {
	context2.SetErrorCode(g.C, errCode)
	response := Response{
		Code:      errCode,
		Data:      data,
		Time:      time.Now(),
		RequestId: context2.GetRequestID(g.C),
		Msg:       constant.MsgFlags[errCode],
	}
	res, err := json.Marshal(response)
	if err != nil {
		trlogger.Errorf(g.C, "smart_request_out: marshal error [%s] ", err.Error())
	}
	trlogger.Debugf(g.C, "smart_request_out: res[%s] ", string(res))
	g.C.JSON(int(httpCode), response)
	return
}

func (g *Gin) ResponseWithMessage(httpCode, errCode int32, data interface{}, msg string) {
	context2.SetErrorCode(g.C, errCode)
	response := Response{
		Code:      errCode,
		Msg:       msg,
		Data:      data,
		Time:      time.Now(),
		RequestId: context2.GetRequestID(g.C),
	}
	res, err := json.Marshal(response)
	if err != nil {
		trlogger.Errorf(g.C, "smart_request_out: marshal error [%s] ", err.Error())
	}
	trlogger.Debugf(g.C, "smart_request_out: res[%s] ", string(res))
	g.C.JSON(int(httpCode), response)
	return
}

func (g *Gin) ResponseSuccess(data interface{}) {
	g.Response(http.StatusOK, constant.SUCCESS, data)
}

func (g *Gin) ResponseError(errCode int32, data interface{}) {
	g.Response(http.StatusOK, errCode, data)
}

func (g *Gin) ResponseErrorWithMsg(errCode int32, msg string) {
	g.ResponseWithMessage(http.StatusOK, errCode, nil, msg)
}

func (g *Gin) ResponseErrorWithMsgAndData(errCode int32, data interface{}, msg string) {
	g.ResponseWithMessage(http.StatusOK, errCode, data, msg)
}

func (g *Gin) BindAndValid(form interface{}) error {
	err := g.C.ShouldBind(form)
	if err != nil {
		trlogger.Warn(g.C, err.Error())
		return err
	}

	valid := validation.Validation{}
	check, err := valid.Valid(form)
	if err != nil {
		trlogger.Warn(g.C, err.Error())
		return err
	}
	if !check {
		trlogger.Warn(g.C, "valid check failed")
		return valid.Errors[0]
	}

	return nil
}
